---
title: Learning ReasonML, part 1
lead: An Interesting Trade Off Between Reliability And Ease Of Adoption
template: post.hbt
date: 2016-04-22
tags: functional, types, reason
draft: true
---

* Talk about the quest for reliability / safety
* ClojureScript is great because immutability is the default, but it is still dynamic
* Elm is great because it's the safest you can get, but the trade off is small number of features and costly interaction with JS
* Fable is great because it is as pragmatic as ClojureScript, with strong typing from ML. But it feels like it's built for current F# / .Net users
* Reason seems to be in the same pragmetic / safety position as Fable, but built for current JS users. Let's try it!

## The Spec

I like to start learning a language with a very simple and well defined spec, usually a function. Trying to implement UI, or anything involving a lot of side effects is usually counter productive for me. And by writing a simple function, we already can learn a lot about the development workflow, the tooling and the ecosystem, which are very important and deserve special attention.

I'll implement the same algorithm I implemented in [Learning Elm, part 1](https://lucasmreis.github.io/blog/learning-elm-part-1/). Recapping:

```
"3S" -> "Three of Spades"
"10H" -> "Ten of Hearts"
"QC" -> "Queen of Clubs"
"AD" -> "Ace of Diamonds"
"3T" -> "-- unknown card --"
```

## The Strategy

When learning Elm, I immediately jumped to a "type driven" solution. Even though I think type driven development lead to more reliable / elegant code, I believe starting from a more JS-style approach is more compatible to the Reason philosophy.

## Setting Up

Let's start by installing Reason's CLI `bsb` and create a new project (as described [in the official website](https://reasonml.github.io/)):

# CHECK THIS COMMANDS MAYBE IT'S BETTER https://reasonml.github.io/guide/editor-tools/global-installation

```
$ npm install -g bs-platform
$ bsb -init my-first-app -theme basic-reason
```

I'm using VS Code with the Reason extension installed. It's a great dev environment, with auto complete, auto formatting, and other niceties. A note on auto formatting: we want to focus on actually solving a problem, and it's a good thing that problems like indentation are not getting in our way. That is something Reason has in common with Elm, and projects like Prettier are trying to do with javascript. I strongly recommend it!

In a real world application that performance is a key requirement, we always need to be aware of bundle size, and be careful with the amount and complexity of the code generated. So I'm always keeping an eye in the compilation result: if we are writing a `demo.re` file, Bucklescript will generate a `demo.bs.js` file in the same folder. Also, for small functions, I recommend copy and pasting to the [Try Reason](https://reasonml.github.io/try/) website, and see both the generated JS and equivalent Ocaml code in real time!

**A tip**: when googling for help, it's usually the case that we find some Ocaml code that could help us. Use the Try Reason to convert it to Reason syntax!

## First Approach

Let's start by editing the `demo.re` and keep `npm start` running in the terminal:

```reasonml
/* it still does not do anything! */
let parseAndRenderCard = cardStr => cardStr;
```

If we open the generated js file:

```js
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
"use strict";

function parseAndRenderCard(cardStr) {
  return cardStr;
}

exports.parseAndRenderCard = parseAndRenderCard;
/* No side effect */
```

It is treating the file as a module! And every variable and function we define in the file will be exported. If we change the value of `package-specs.module` in the `bs-config.json` file from `commonjs` to `es6`, we'll have:

```js
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
"use strict";

function parseAndRenderCard(cardStr) {
  return cardStr;
}

export { parseAndRenderCard };
/* No side effect */
```

Which is great to integrate your generated files into a webpack bundled project.

Have you noticed the "No side effect" comment? Bucklescript knows if your code is pure or not! I love this feature, and helps the practice of trying to have as much as your code pure as possible. If we add a log `Js.log(parseAndRenderCard("3C"));`, we can see that the comment changes:

```js
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
"use strict";

function parseAndRenderCard(cardStr) {
  return cardStr;
}

console.log("3C");

export { parseAndRenderCard };
/*  Not a pure module */
```

But now that the side effect was added, we can see an unexpected (at least for me!) behavior: the compiler understood that `parseAndRenderCard` is the identity function, and generated `console.log("3C");`, and not `console.log(parseAndRenderCard("3C"));`! Even with such a simple piece of code we can already see some cool optimizations.

But, you may ask, why does it still generates the function, if it is not being used? It's only because it's being exported. We can make the function not being exported if we put it in a block inside the module, like this:

```reason
{
  let parseAndRenderCard = cardStr => cardStr;
  Js.log(parseAndRenderCard("3C"));
};
```

It will generate:

```js
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
"use strict";

console.log("3C");

export {};
/*  Not a pure module */
```

Which is amazing: less code to parse, quicker page load :)

I want to talk about one more cool feature also present in Elm and F# before going to our function: the pipe operator `|>`. It makes the code much cleaner most of the times, and saves lots of ugly parenthesis. As an example, these two lines of code are equivalent:

```
Js.log(parseAndRenderCard("3C"));
```

```
"3C" |> parseAndRenderCard |> Js.log;
```

Ok! Enough talk, let's implement our function. Let's break the problem in smaller ones, and let's start with a parser for a suit:

```
let parseAndRenderSuit = suitStr =>
  switch suitStr {
  | "H" => "Hearts"
  | "D" => "Diamonds"
  | "C" => "Clubs"
  | "S" => "Spades"
  };

"C" |> parseAndRenderSuit |> Js.log;
```

`switch` is the syntax for pattern matching in Reason.
